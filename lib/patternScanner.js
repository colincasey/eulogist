// Generated by CoffeeScript 1.3.3
(function() {
  var CONVERSION_CHARACTER, ENDING_SPACE, ESCAPED_PERCENT, FORMATTING, IGNORE, PADDING_MODIFIER, PATTERN_START, Pattern, PatternScanner, StringScanner, TRUNCATE_MODIFIER, TRUNCATE_MODIFIER_START;

  StringScanner = require('pstrscan');

  Pattern = require('./pattern');

  ESCAPED_PERCENT = /%%/;

  PATTERN_START = /%/;

  CONVERSION_CHARACTER = /([cCdFlLmMnprtxX])/;

  IGNORE = /[\s]/;

  PADDING_MODIFIER = /(-?\d+)/;

  TRUNCATE_MODIFIER_START = /\./;

  TRUNCATE_MODIFIER = /(\d+)/;

  FORMATTING = /\{([^}]*)\}/;

  ENDING_SPACE = /\s{1}/;

  module.exports = PatternScanner = (function() {

    function PatternScanner(pattern) {
      this.pattern = pattern;
      this.scanner = new StringScanner(pattern);
    }

    PatternScanner.prototype.hasPatterns = function() {
      return !this.scanner.hasTerminated();
    };

    PatternScanner.prototype.nextPattern = function() {
      var patternContent, start;
      if (this.scanner.hasTerminated()) {
        throw new Error('end of pattern has been reached');
      }
      this._patternReset();
      this.scanner.skip(IGNORE);
      this.scanner.skip(ESCAPED_PERCENT);
      if (this.scanner.scan(PATTERN_START)) {
        start = this.scanner.getPos() - 1;
        patternContent = this.scanner.scanUntil(CONVERSION_CHARACTER);
        if (patternContent == null) {
          this._throwParseError('no matching conversion character', start);
        }
        this._parsePattern(patternContent);
        this._parseSeparator();
      } else {
        throw new Error("no conversion patterns are present in '" + this.pattern + "'");
      }
      return this._createPattern();
    };

    PatternScanner.prototype._createPattern = function() {
      return new Pattern({
        conversionCharacter: this.conversionCharacter,
        padding: this.padding,
        truncate: this.truncate,
        format: this.format,
        separator: this.separator
      });
    };

    PatternScanner.prototype._patternReset = function() {
      this.conversionCharacter = null;
      this.padding = null;
      this.truncate = null;
      this.format = null;
      return this.separator = null;
    };

    PatternScanner.prototype._throwParseError = function(msg, pos) {
      var errorIndicator;
      errorIndicator = pos === 0 ? "-->" + this.pattern : "" + (this.pattern.substring(0, pos)) + "-->" + (this.pattern.substring(pos));
      throw new Error("" + msg + " at position " + pos + ": '" + errorIndicator + "'");
    };

    PatternScanner.prototype._throwPatternParseError = function(msg, pos, contentScanner) {
      var currentPos, patternStr;
      currentPos = this.scanner.getPos();
      patternStr = contentScanner.getSource();
      return this._throwParseError(msg, currentPos - patternStr.length + pos);
    };

    PatternScanner.prototype._parseSeparator = function() {
      var currentPos, nextPattern;
      currentPos = this.scanner.getPos();
      nextPattern = this.scanner.scanUntil(/%[^%]/);
      if (nextPattern != null) {
        this.separator = this.pattern.substring(currentPos, this.scanner.getPos() - 2);
        if (this.separator === '') {
          this.separator = null;
        }
        return this.scanner.unscan();
      } else {
        return this.separator = null;
      }
    };

    PatternScanner.prototype._parsePattern = function(patternContent) {
      var contentScanner;
      contentScanner = new StringScanner(patternContent);
      this._parsePadding(contentScanner);
      this._parseTruncate(contentScanner);
      this._parseConversionCharacter(contentScanner);
      return this._parseFormatting();
    };

    PatternScanner.prototype._parsePadding = function(contentScanner) {
      var badValue, end, intValue, start, value;
      start = contentScanner.getPos();
      value = contentScanner.scan(PADDING_MODIFIER);
      if (value != null) {
        intValue = parseInt(value);
        if (isNaN(intValue) || intValue === 0) {
          this._throwPatternParseError("invalid padding modifier '" + value + "'", start, contentScanner);
        }
        this.padding = intValue;
      }
      if (!((contentScanner.check(TRUNCATE_MODIFIER_START) != null) || contentScanner.check(CONVERSION_CHARACTER))) {
        end = contentScanner.checkUntil(CONVERSION_CHARACTER) - 1;
        badValue = contentScanner.getSource().substring(contentScanner.getPos(), contentScanner.getPos() + end);
        return this._throwPatternParseError("invalid padding modifier '" + badValue + "'", start, contentScanner);
      }
    };

    PatternScanner.prototype._parseTruncate = function(contentScanner) {
      var badValue, end, intValue, start, value;
      if (contentScanner.scan(TRUNCATE_MODIFIER_START)) {
        start = contentScanner.getPos();
        value = contentScanner.scan(TRUNCATE_MODIFIER);
        if (value != null) {
          intValue = parseInt(value);
          if (intValue <= 0) {
            this._throwPatternParseError("invalid truncate modifier '" + value + "'", start, contentScanner);
          }
          return this.truncate = intValue;
        } else {
          end = contentScanner.checkUntil(CONVERSION_CHARACTER) - 1;
          badValue = contentScanner.getSource().substring(start, start + end);
          return this._throwPatternParseError("invalid truncate modifier '" + badValue + "'", start, contentScanner);
        }
      }
    };

    PatternScanner.prototype._parseConversionCharacter = function(contentScanner) {
      return this.conversionCharacter = contentScanner.scan(CONVERSION_CHARACTER);
    };

    PatternScanner.prototype._parseFormatting = function() {
      var start;
      start = this.scanner.getPos();
      if (this.scanner.scan(FORMATTING) != null) {
        this.format = this.scanner.getCapture(1);
        if (!this.format) {
          return this._throwParseError("no format specified", start);
        }
      }
    };

    return PatternScanner;

  })();

}).call(this);
