// Generated by CoffeeScript 1.3.3
(function() {
  var EventEmitter, Interpreter, PatternScanner, StringScanner,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  EventEmitter = require('events').EventEmitter;

  StringScanner = require('pstrscan');

  PatternScanner = require('./patternScanner');

  module.exports = Interpreter = (function(_super) {

    __extends(Interpreter, _super);

    function Interpreter(streamer, format) {
      this._processData = __bind(this._processData, this);
      this.buffer = '';
      this.scanner = new StringScanner(this.buffer);
      this.logData = {};
      this.patterns = this._buildPatterns(format);
      this.currentPattern = this.patterns[0];
      this.readingStackTrace = false;
      this.streamer = streamer;
      this.streamer.on('data', this._processData);
    }

    Interpreter.prototype._processData = function(data) {
      this.buffer += data;
      this.scanner.concat(data);
      if (!this.ready) {
        return this._scanToStart();
      } else if (this.readingStackTrace) {
        return this._readStackTrace();
      } else {
        return this._continueMatching();
      }
    };

    Interpreter.prototype._scanToStart = function() {
      var capture, result, startPosition;
      if (this.scanner.check(this.patterns[0].getMatcher())) {
        this.ready = true;
        return this._continueMatching();
      } else {
        result = this.scanner.scanUntil(this.patterns[0].getMatcher());
        if (result != null) {
          capture = this.scanner.getCapture(1);
          startPosition = this.scanner.getPos() - capture.length - 1;
          this.scanner.setPosition(startPosition);
          this.ready = true;
          return this._continueMatching();
        }
      }
    };

    Interpreter.prototype._continueMatching = function() {
      var pattern, result;
      pattern = this.currentPattern;
      result = pattern.scan(this.scanner);
      if (result != null) {
        this.logData[pattern.name] = result;
        return this._nextPattern();
      }
    };

    Interpreter.prototype._nextPattern = function() {
      var nextIndex;
      nextIndex = this.patterns.indexOf(this.currentPattern) + 1;
      if (nextIndex === this.patterns.length) {
        this.currentPattern = this.patterns[0];
        if (this.logData.priority && this.logData.priority.toLowerCase() === 'error') {
          this.readingStackTrace = true;
          this.startOfStackTrace = this.scanner.getPos();
          return this._readStackTrace();
        } else {
          this._logDataComplete();
          return this._continueMatching();
        }
      } else {
        this.currentPattern = this.patterns[nextIndex];
        return this._continueMatching();
      }
    };

    Interpreter.prototype._readStackTrace = function() {
      var capture, endOfStackTrace, result, stackTrace;
      result = this.scanner.scanUntil(this.currentPattern.getMatcher());
      if (result != null) {
        capture = this.scanner.getCapture(1);
        endOfStackTrace = this.scanner.getPos() - capture.length - 1;
        this.scanner.setPos(endOfStackTrace);
        stackTrace = this.buffer.substring(this.startOfStackTrace, endOfStackTrace);
        this.logData.stackTrace = stackTrace;
        this._logDataComplete();
        return this._continueMatching();
      }
    };

    Interpreter.prototype._logDataComplete = function() {
      this.buffer = this.buffer.substring(this.scanner.getPos());
      this.scanner = new StringScanner(this.buffer);
      this.readingStackTrace = false;
      this.emit('log', this.logData);
      return this.logData = {};
    };

    Interpreter.prototype._buildPatterns = function(format) {
      var patternScanner, patterns;
      patterns = [];
      patternScanner = new PatternScanner(format);
      while (patternScanner.hasPatterns()) {
        patterns.push(patternScanner.nextPattern());
      }
      if (patterns.length === 0) {
        throw new Error('format could not be properly parsed: ' + format);
      }
      return patterns;
    };

    return Interpreter;

  })(EventEmitter);

}).call(this);
